# 官方题解
## 法一：动态规划
给定一个有序序列n1⋯n，为了构建出一棵二叉搜索树，可以遍历每个数字 ii，将该数字作为树根，将1⋯(i−1) 序列作为左子树，将n(i+1)⋯n序列作为右子树。接着可以按照同样的方式递归构建左子树和右子树。  
在上述构建的过程中，由于根的值不同，因此能保证每棵二叉搜索树是唯一的。   
由此可见，原问题可以分解成规模较小的两个子问题，且子问题的解可以复用。因此，可以想到使用动态规划来求解本题。  
```java
class Solution {
    public int numTrees(int n) {
        int[] G = new int[n + 1];
        G[0] = 1;
        G[1] = 1;

        for (int i = 2; i <= n; ++i) {
            for (int j = 1; j <= i; ++j) {
                G[i] += G[j - 1] * G[i - j];
            }
        }
        return G[n];
    }
}
```
```
执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户
内存消耗：35.1 MB, 在所有 Java 提交中击败了76.37%的用户
```
时间复杂度 : O(n^2)    
空间复杂度 : O(n)
## 法二：数学
满足卡塔兰数公式。
```java
class Solution {
    public int numTrees(int n) {
        // 提示：我们在这里需要用 long 类型防止计算过程中的溢出
        long C = 1;
        for (int i = 0; i < n; ++i) {
            C = C * 2 * (2 * i + 1) / (i + 2);
        }
        return (int) C;
    }
}
```
```
执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户
内存消耗：35.2 MB, 在所有 Java 提交中击败了52.71%的用户
```
时间复杂度 : O(n)  
空间复杂度 : O(1)
